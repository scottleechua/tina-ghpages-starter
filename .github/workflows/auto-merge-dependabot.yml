name: Auto-Approve Dependabot PRs

on:
  pull_request:
    types: [opened, synchronize, reopened]
  check_suite:
    types: [completed]
  status: {}

permissions:
  pull-requests: write
  checks: read
  actions: read

jobs:
  dependabot:
    runs-on: ubuntu-latest
    if: |
      (github.event.pull_request.user.login == 'dependabot[bot]' || 
       github.event.pull_request.user.login == 'dependabot-preview[bot]') ||
      github.event_name == 'check_suite' ||
      github.event_name == 'status'
    steps:
      - name: Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v1
        with:
          github-token: "${{ secrets.GITHUB_TOKEN }}"

      - name: Get PR number and verify Dependabot
        id: pr_number
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber;
            let pr;
            
            if (context.payload.pull_request?.number) {
              prNumber = context.payload.pull_request.number;
            } else {
              // For check_suite and status events, find PR by commit SHA
              const sha = context.payload.check_suite?.head_sha || 
                          context.payload.commit?.sha || 
                          context.sha;
              
              if (sha) {
                const { data: prsByCommit } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: sha
                });
                
                const openPR = prsByCommit.find(pr => pr.state === 'open');
                if (openPR) {
                  prNumber = openPR.number;
                }
              }
            }
            
            if (!prNumber) {
              core.info('Could not find PR number, skipping...');
              core.setOutput('is_dependabot', 'false');
              return;
            }
            
            // Get PR details to verify it's from Dependabot
            pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const isDependabot = pr.data.user.login === 'dependabot[bot]' || 
                                 pr.data.user.login === 'dependabot-preview[bot]';
            
            if (!isDependabot) {
              core.info(`PR #${prNumber} is not from Dependabot, skipping...`);
              core.setOutput('is_dependabot', 'false');
              return;
            }
            
            core.setOutput('is_dependabot', 'true');
            core.setOutput('number', prNumber.toString());

      - name: Wait for checks and verify mergeable
        if: steps.pr_number.outputs.is_dependabot == 'true'
        uses: actions/github-script@v7
        id: verify
        with:
          script: |
            const prNumber = parseInt('${{ steps.pr_number.outputs.number }}');
            const workflowName = '${{ github.workflow }}';
            const currentRunId = ${{ github.run_id }};
            const maxWait = 300; // 5 minutes max wait
            const checkInterval = 10; // Check every 10 seconds
            let waited = 0;
            
            // Get the current workflow run to identify its check suite
            const { data: currentRun } = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: currentRunId
            });
            
            const currentCheckSuiteId = currentRun.check_suite_id;
            
            while (waited < maxWait) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Check if PR is mergeable (no conflicts)
              if (pr.mergeable === false) {
                core.info('PR is not mergeable (has conflicts)');
                core.setOutput('can_approve', 'false');
                return;
              }
              
              // Get check runs
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              // Filter out this workflow's check runs by check suite ID and name
              const otherCheckRuns = checkRuns.check_runs.filter(run => {
                // Exclude check runs from the same check suite (this workflow)
                if (run.check_suite && run.check_suite.id === currentCheckSuiteId) {
                  return false;
                }
                // Also exclude by name as a fallback
                if (run.name === workflowName || 
                    run.name.includes('Auto-Approve Dependabot PRs') ||
                    run.name.includes('Dependabot auto-approve')) {
                  return false;
                }
                return true;
              });
              
              // Get combined status (excluding this workflow)
              const { data: status } = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              // Filter status checks to exclude this workflow
              const otherStatusChecks = status.statuses.filter(status => 
                status.context !== workflowName &&
                !status.context.includes('Auto-Approve Dependabot PRs') &&
                !status.context.includes('Dependabot auto-approve')
              );
              
              // Check if all other check runs have passed
              const allOtherCheckRunsPassed = otherCheckRuns.length === 0 || 
                otherCheckRuns.every(run => 
                  run.status === 'completed' && 
                  (run.conclusion === 'success' || run.conclusion === 'skipped')
                );
              
              // Check if all other status checks have passed
              // Calculate combined state from filtered statuses only
              const otherStatusStates = otherStatusChecks.map(s => s.state);
              const allOtherStatusChecksPassed = otherStatusChecks.length === 0 ||
                (otherStatusStates.every(state => state === 'success') && 
                 !otherStatusStates.includes('failure') && 
                 !otherStatusStates.includes('error'));
              
              // If there are no other checks, we can approve immediately if mergeable
              if (otherCheckRuns.length === 0 && otherStatusChecks.length === 0 && pr.mergeable === true) {
                core.info('No other checks found, PR is mergeable!');
                core.setOutput('can_approve', 'true');
                return;
              }
              
              if (allOtherCheckRunsPassed && allOtherStatusChecksPassed && pr.mergeable === true) {
                core.info('All other checks passed and PR is mergeable!');
                core.setOutput('can_approve', 'true');
                return;
              }
              
              // If any check failed, don't wait
              const hasFailedCheck = otherCheckRuns.some(run => 
                run.status === 'completed' && run.conclusion === 'failure'
              ) || otherStatusChecks.some(status => status.state === 'failure' || status.state === 'error');
              
              if (hasFailedCheck) {
                core.info('Some checks failed');
                core.setOutput('can_approve', 'false');
                return;
              }
              
              const pendingCount = otherCheckRuns.filter(run => run.status !== 'completed').length +
                                   otherStatusChecks.filter(status => status.state === 'pending').length;
              
              core.info(`Waiting for ${pendingCount} check(s) to complete... (waited ${waited}s)`);
              await new Promise(resolve => setTimeout(resolve, checkInterval * 1000));
              waited += checkInterval;
            }
            
            core.info('Timeout waiting for checks');
            core.setOutput('can_approve', 'false');

      - name: Approve PR
        if: steps.verify.outputs.can_approve == 'true'
        run: |
          gh pr review --approve "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url || format('https://github.com/{0}/pull/{1}', github.repository, steps.pr_number.outputs.number) }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
