{"version":3,"mappings":"0RAAqB,UAAoB,CACrC,MAAMA,EAAU,SAAS,cAAc,MAAM,EAAE,QAC/C,GAAIA,GAAWA,EAAQ,UAAYA,EAAQ,SAAS,eAAe,EAC/D,OAEJ,UAAWC,KAAQ,SAAS,iBAAiB,2BAA2B,EACpEC,EAAeD,CAAI,EAEvB,IAAI,iBAAkBE,GAAc,CAChC,UAAWC,KAAYD,EACnB,GAAIC,EAAS,OAAS,YAGtB,UAAWC,KAAQD,EAAS,WACpBC,EAAK,UAAY,QAAUA,EAAK,MAAQ,iBACxCH,EAAeG,CAAI,CAGvC,CAAK,EAAE,QAAQ,SAAU,CAAE,UAAW,GAAM,QAAS,EAAI,CAAE,EACvD,SAASC,EAAaC,EAAQ,CAC1B,MAAMC,EAAY,GAClB,OAAID,EAAO,YACPC,EAAU,UAAYD,EAAO,WAC7BA,EAAO,iBACPC,EAAU,eAAiBD,EAAO,gBAClCA,EAAO,cAAgB,kBACvBC,EAAU,YAAc,UACnBD,EAAO,cAAgB,YAC5BC,EAAU,YAAc,OAExBA,EAAU,YAAc,cACrBA,CACV,CACD,SAASN,EAAeD,EAAM,CAC1B,GAAIA,EAAK,GAEL,OACJA,EAAK,GAAK,GAEV,MAAMO,EAAYF,EAAaL,CAAI,EACnC,MAAMA,EAAK,KAAMO,CAAS,CAC7B,CACL,KChCO,MAAMC,GAAU,MAAO,CAC5B,SACA,uBACF,IAMM,CACJ,MAAMC,EAA2B,GAiB3BC,EADuBC,EAAQC,EAfR,CAC3B,oBAAsBR,GACfA,EAAK,KAUHA,EATE,CACL,GAAGA,EACH,KAAM,CACJ,KAAM,OAEN,MAAO,gBACT,EAIN,CAEiE,EAE7DS,EAAW,IAAIC,GAAWC,CAAM,EAEhCC,EACJZ,GACc,OACP,OACL,GAAGA,EACH,aAAc,CACZ,GAAIA,EAAK,cAAgB,CACvB,KAAM,eACN,WAAY,CAAC,CACf,EACA,WACE,CAAC,KAAIA,IAAK,eAALA,cAAmB,aAAc,GAAK,GAAGa,EAAU,CAC5D,EACF,EAGIC,EAAU,CACdC,EACAf,IACG,CACH,IAAIgB,EAAehB,EACnB,MAAMiB,EAAsB,GACvB,iBAASC,GAAS,CAErBF,EAAeA,EAAaE,GACvB,MAAM,QAAQF,CAAY,GAEzBA,EAAa,OAAS,SACdC,OAAKD,EAAa,KAAK,KAAK,CAE1C,CACD,EACMC,GAGHE,EAAmD,CACvDnB,EACAoB,EACAC,EACAN,EACAO,IACS,CACT,MAAML,EAAYH,EAAQC,EAAMO,EAAU,EAAE,EACtCC,EAAYC,GAA2B,SAC3C,MAAMC,EAAyB,GA+B/B,OA9BElB,EACAiB,EACAE,EAAoBjB,EAAU,CAC5B,MAAO,CACL,MAAQT,GAAS,WAEf,GADAS,EAAS,MAAMT,CAAI,EACfA,EAAK,KAAK,QAAUwB,EAAU,KAAK,MACjCxB,QAAK,eAALA,QAAmB,WAAW,OAAQ,CAClC,QAAUuB,EAASvB,CAAI,EAC7ByB,SAAO,KAAK,CACV,KAAMzB,EAAK,KAAK,MAChB,QAAOA,IAAK,QAALA,cAAY,QAASA,EAAK,KAAK,MACtC,OAAQ2B,EAAQ,OACjB,EAEM,QAEPF,EAAO,KAAK,CACV,KAAMzB,EAAK,KAAK,MAChB,QAAOA,IAAK,QAALA,cAAY,QAASA,EAAK,KAAK,MACvC,CAGP,EACA,MAAQA,GAAS,CACfS,EAAS,MAAMT,CAAI,CACrB,CACF,EACD,GAECyB,WAAQ,OACH,CACL,KAAMD,EAAU,KAAK,MACrB,QAAOI,IAAU,QAAV,cAAiB,QAASJ,EAAU,KAAK,MAChD,UAGK,CACL,KAAMA,EAAU,KAAK,MACrB,QAAOK,IAAU,QAAV,cAAiB,QAASL,EAAU,KAAK,MAEpD,EAEIM,EAASP,EAASvB,CAAI,EAsCtByB,GArCeA,GAA2C,CAC9D,GAAI,CAACA,EACH,MAAO,GAcH,SAZU,CACdM,EACAC,IAEAD,EAAM,OACJ,CAACD,EAAgCZ,KAAa,CAC5C,GAAGY,EACH,CAACZ,EAAKc,IAAO,CAAC,GAAIF,EAAOZ,EAAKc,KAAS,CAAC,EAAId,CAAI,IAElD,CAAC,IAGkBO,EAAQ,OAAO,EAChCQ,EAAwB,GACvB,sBAAQC,CAAM,EAAE,QAAQ,CAAC,CAACC,EAAMJ,CAAK,IAAM,CAChD,MAAMK,EAAoB,GACpBL,UAASb,IAAS,QACtBU,KAAK,SAAL,QAAa,QAASS,IAAUD,EAAU,KAAKC,EAAK,EAAC,CACtD,EACK,QAAYN,EAAM,GAAG,KACrBO,EAAaP,EAAM,GAAG,MACxBK,WAAW,OACbH,EAAc,KAAK,CACjB,KAAMM,EACN,MAAOD,EACP,OAAQF,EACT,EAEDH,EAAc,KAAK,CAAE,KAAMM,EAAW,MAAOD,EAAY,CAC3D,CACD,EACML,IAEkBH,EAAO,MAAM,EASlCL,WAAQ,OACVpB,EAAW,KAAK,CACd,KAAMyB,EAAO,KACb,MAAOA,EAAO,MACd,SACA,KAAMb,EACP,EAEDZ,EAAW,KAAK,CACd,KAAMyB,EAAO,KACb,MAAOA,EAAO,MACd,KAAMb,EACP,CAEL,EAGIuB,EAA8B,CAClC,eAAgB,CACd,MAAQxC,GAAS,CACfS,EAAS,MAAMT,CAAI,CACrB,EACA,MAAQA,GAAS,CACfS,EAAS,MAAMT,CAAI,CACrB,CACF,EACA,MAAO,CACL,MAAO,CAACA,EAAMgC,EAAKS,EAAQ1B,EAAMO,IAAc,CAC7Cb,EAAS,MAAMT,CAAI,EACb,QAAOS,EAAS,UACtB,GAAIiC,EAAM,CACF,QAAYC,EAAeD,CAAI,EAkBjC,GAjBAE,EAAkBC,CAAS,GACzBA,EAAU,OAAS,QAIrBC,EAAcD,CAAS,GACXA,EAAU,WAEhB,MAAOH,GACJA,EACJ,gBACA,KAAMK,GAAUA,EAAM,OAAS,MAAM,CACzC,GAKDC,EAAeH,CAAS,GAExBA,EAAU,gBAAgB,KAAME,GAAUA,EAAM,OAAS,MAAM,EAE/D,OAAOnC,EAAcZ,CAAkC,CAG7D,CACF,CACF,GAEIiD,EAAgC,CACpC,eAAgB,CACd,MAAQjD,GAAS,CACfS,EAAS,MAAMT,CAAI,CACrB,EACA,MAAQA,GAAS,CACfS,EAAS,MAAMT,CAAI,CACrB,CACF,EACA,MAAO,CACL,MAAO,CAACA,EAAMgC,EAAKS,EAAQ1B,EAAMO,IAAc,CAC7Cb,EAAS,MAAMT,CAAI,EACb,QAAOS,EAAS,UACtB,GAAIiC,EAAM,CACF,QAAYC,EAAeD,CAAI,EAoBjC,GAnBAE,EAAkBC,CAAS,GACzBA,EAAU,OAAS,QAKrBC,EAAcD,CAAS,GACXA,EAAU,WAEhB,MAAOH,GACJA,EACJ,gBACA,KAAMK,GAAUA,EAAM,OAAS,MAAM,CACzC,GAMDC,EAAeH,CAAS,GAExBA,EAAU,gBAAgB,KAAME,GAAUA,EAAM,OAAS,MAAM,EAE/D,SAAc/C,EAAMgC,EAAKS,EAAQ1B,EAAMO,CAAS,EACzC,EAGb,CACF,CACF,GAEI4B,EAAiB3C,EACrBD,EACAoB,EAAoBjB,EAAU+B,CAAc,GAE9CjC,SAAQ2C,EAAgBxB,EAAoBjB,EAAUwC,CAAgB,CAAC,EAEhE,CAAE,iBAAgB,aAC3B,EAMMjD,GAAOmD,EAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA2BlB,EACGtC,GAEJb,GAAK,YAAY,GAAG,aAAa,WCjRtBoD,GAEXC,EACE,CACE,QAAS,CAAC,EACV,OAAQ,CACN,QAAS,CAAC,EACV,SAAU,CAAC,EAaX,OAAQ,CAAC,CAcX,EACA,GAAI,YACJ,QAAS,eACT,OAAQ,CACN,aAAc,CACZ,OAAQ,CACN,IAAK,cACL,OAAQ,CACN,CACE,QAAS,CAAC,mBAAoB,cAAc,EAC5C,OAAQ,OACV,CACF,EACA,QAAS,CACP,CACE,QAAS,cACT,OAAQ,OACV,CACF,CACF,CACF,EACA,MAAO,CAAC,EACR,MAAO,CAAC,CACV,CACF,EACA,CACE,QAAS,CACP,aAAcC,GAAYC,IACjB,CACL,KAAM,iBACN,MAAOA,EAAQ,IAElB,EACD,YAAa,CAACC,EAAUC,IAAU,CACxB,cAAMA,EAAM,IAAI,CAC1B,EACA,iBAAkBC,EAAO,CAACH,EAASE,KAE1B,CAAE,GAAGF,EAAS,KAAME,EAAM,KAAK,KAAM,KAAMA,EAAM,KAAK,IAAK,EACnE,CACH,EACA,SAAU,CACR,YAAa,MAAOF,GAAY,CACxB,QAAOA,EAAQ,IAAI,IAAI,KACzB,MACAA,EAAQ,KACVvD,EAAOuD,EAAQ,KAoCfvD,GAlCiB,MAAM2D,EAAK,QAG1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SA6BA,CAAE,UAAW,CAAE,GAAIJ,EAAQ,GAAK,IAElB,KAElB,MAAM5C,EAAS4C,EAAQ,IAAI,IAAI,KAAK,OACpC,GAAI,CAAC5C,EACG,UAAI,MAAM,yBAAyB,EAE3C,MAAMiD,EAAajD,EAAO,cACxBX,EAAK,aAAa,WAAW,MAE3B,MAWJ,GAVI4D,EAAW,UACbC,EAAWD,EAAW,UAAU,KAAMC,GAAa,CAC7C,UAAOA,GAAa,SAChB,UAAI,MAAM,gCAAgC,EAE3CA,SAAS,OAAS7D,EAAK,aAAa,SAC5C,EAEU6D,IAET,CAACA,EACH,MAAM,IAAI,MACR,oCAAoC7D,EAAK,aAAa,QAG1D,MAAM8D,EAAeC,GAAY,CAC/B,aACA,SAAU/D,EAAK,aAAa,SAC5B,SACA,WACD,EACKgE,EAAW,MAAOC,GAAqC,CACvD,IACF,MAAMC,EAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAQvB,MAAMX,EAAQ,IAAI,IAAI,KAAK,QAAQW,EAAgB,CACjD,UAAW,CACT,WAAYlE,EAAK,aAAa,WAAW,KACzC,aAAcA,EAAK,aAAa,aAChC,OAAQW,EAAO,iBACbX,EAAK,aAAa,WAAW,KAC7BiE,CACF,CACF,EACD,EACOV,MAAI,OAAO,QAAQ,iBAAiB,QACrCY,GACPZ,EAAQ,IAAI,OAAO,MACjB,4CAEF,QAAQ,MAAMY,CAAC,CACjB,GAEIC,EAAa,CACjB,GAAIb,EAAQ,GACZ,MACEvD,EAAK,aAAa,OAASA,EAAK,aAAa,WAAW,MAC1D,cAAeA,EAAK,gBACpB,OAAQ8D,EAAa,OACrB,YAEIO,EAAkBd,EAAQ,gBAczB,OAAE,KAbIe,GACXF,EACAb,EAAQ,IACPgB,GACKF,EACKA,EAAgBE,EAAMhB,EAAQ,GAAG,EAEjCgB,EAAK,WAAWA,EAAK,UAAU,EAG1C,EAEF,EACe,KAAMvE,EACvB,CACF,CACF,CACF,EAgCWwE,GAAuB,CAACC,EAAcC,KAc1C,CAAE,WAbWN,GACX,IAAIO,EAAKP,CAAU,EAYP,iBAVuB,CAC1CA,EACAQ,IAEa,IAAID,EAAK,CACpB,GAAGP,EACH,OAAQ,CAAE,OAAQ,GAAM,GAAGQ,CAAQ,EACpC,IAMQN,GAAY,CACvBF,EACAK,EACArE,EACAsE,EAAyB,GACzBV,IACyB,CACnB,MAAE,aAAY,oBAAqBQ,GAGzC,EACMK,EAAU,UACZ,MACAC,EACJ,MAAMC,EAAO,IAAM,CACPD,KAER,MAgBA,IAdA1E,EACK4E,IACL,CACE,aACA,aACA,mBACA,MACF,EACAP,GAGFO,EAAOC,EAAWb,CAAU,EAG1B,EAAEY,aAAgBL,GAAO,CAC3B,GAAIG,IAAYD,EACd,OAEI,UAAI,MAAM,sCAAsC,CACxD,CAEO,SACT,EC3SaK,EAA+D,CAC1E,GAAI,KACJ,KAAM,KACN,UAAW,CAAC,EACZ,YAAa,CAAC,EACd,UAAW,CAAC,EACZ,aAAc,CAAE,KAAM,WAAY,YAAa,EAAG,EAClD,OAAQ,IACV,EACaC,GAEX9B,EACE,CACE,QAAS,CAAC,EACV,OAAQ,CACN,QAAS,CAAC,EACV,SAAU,CAAC,EAmBX,OAAQ,CAAC,CAwCX,EACA,GAAI,YACJ,KAAM,WACN,OAAQ,CACN,SAAU,CACR,QAAS,OACT,OAAQ,CACN,KAAM,CACJ,MAAO,QACP,GAAI,CACF,UAAW,CACT,OAAQ,cACV,EACA,aAAc,CACZ,OAAQ,SACV,EACA,eAAgB,CACd,QAAS,WACX,CACF,CACF,EACA,aAAc,CACZ,OAAQ,CACN,IAAK,cACL,OAAQ,CACN,CACE,QAAS,qBACT,OAAQ,SACV,CACF,EACA,QAAS,CACP,CACE,QAAS,cACT,OAAQ,OACV,CACF,CACF,CACF,EACA,QAAS,CACP,GAAI,CACF,eAAgB,CACd,OAAQ,SACV,CACF,CACF,EACA,QAAS,CACP,OAAQ,CACN,IAAK,SACL,OAAQ,CACN,CACE,OAAQ,OACV,CACF,EACA,QAAS,CACP,CACE,QAAS,wBACT,OAAQ,SACV,CACF,CACF,CACF,EACA,MAAO,CACL,MAAO,cACP,OAAQ,CACN,IAAK,kBACP,EACA,GAAI,CACF,SAAU,CACR,OAAQ,MACV,EACA,aAAc,CACZ,OAAQ,MACV,EACA,aAAc,CACZ,OAAQ,SACV,CACF,CACF,EACA,MAAO,CAAC,CACV,CACF,CACF,CACF,EACA,CACE,QAAS,CACP,YAAa,CAACG,EAAUC,IAAU,QAAQ,MAAMA,EAAM,IAAI,EAC1D,sBAAuBC,EAAO,CAACH,EAASE,IAAU,CAC5C,KAAM,gBAAgB2B,EAAY,CAKhC,GAJA7B,EAAQ,YAAYE,EAAM,KAAK,KAI/B,CAACA,EAAM,KAAK,GACP,SAEH,QAAeF,EAAQ,UAAU,KACpC8B,GAAQA,EAAI,aAAa,OAAS5B,EAAM,KAAK,IAE1C4B,EAAM,CACV,IAAKC,GACHlC,GAAgB,YAAY,CAC1B,GAAIK,EAAM,KAAK,GACf,IAAKF,EAAQ,IACb,gBAAiBA,EAAQ,gBACzB,KAAM,KACN,KAAMgC,GAAgB,KACvB,CACH,GAGK,OACL,GAAGhC,EACH,YAAa,CACX,GAAGA,EAAQ,YACX,CAACE,EAAM,KAAK,IAAK,CACf,GAAG4B,EACH,iBAAkB5B,EAAM,KAAK,gBAC/B,CACF,EACF,KAEQ,sBAAMA,EAAM,IAAI,EACjBF,CACT,CACD,EACD,MAAOG,EAAQH,IACbA,EAAQ,IAAI,MAAM,MAAM,QAASyB,GAAS,CACxCzB,EAAQ,IAAI,MAAM,OAAOyB,EAAK,EAAE,EACjC,EACM,CACL,GAAGE,EACH,gBAAiB3B,EAAQ,gBACzB,IAAKA,EAAQ,IAEb,OAAQA,EAAQ,QAEnB,EACD,mBAAoBG,EAAO,CAACH,EAASE,KAC5B,CACL,GAAGF,EACH,GAAGE,EAAM,MAEZ,EACD,UAAWC,EAAO,CAACH,EAASE,KACnB,CACL,GAAGF,EACH,OAAQE,EAAM,OAEjB,EACD,YAAaC,EAAO,CAACH,EAASE,IAAU,SACtC,OAAIF,EAAQ,UACF1B,8BAAQ,gBAAR,QAAuB,YAAY,CACzC,KAAM,aACN,GAAI0B,EAAQ,GACZ,KAAME,EAAM,KAAK,QAGd,CACL,GAAGF,EACH,KAAME,EAAM,KAAK,KACnB,CACD,CACH,EACA,SAAU,CACR,OAAQ,MAAOF,GAAY,CACzB,MAAMiC,EAAajC,EAAQ,IAAI,IAAI,KAAK,OAClCkC,EAAYlC,EAAQ,IAAI,IAAI,KAAK,UACjCmC,EAA4D,GAC5DC,EAAU,MAAMC,GAAU,CAC9B,OAAQH,EACR,OAAQI,EAAQtC,EAAQ,YAAY,EACpC,UAAWA,EAAQ,KACnB,eAAgBA,EAAQ,UACxB,cAAe,CAACuC,EAAQvB,EAAMf,EAAUuC,IAAS,WAC/C,MAAMxD,EAAYwD,EAAK,UAUjBC,EAAoB,GACrBD,aAAW,QAASE,GAAc,CACjCA,EAAU,OACJD,OAAKC,EAAU,MAAM,KAAK,CACpC,CACD,EACD,IAAIC,EAAQJ,EAAOvD,GAiBnB,GAhBK2D,GACKF,UAASG,GAAU,CACzB,MAAMC,EAAaN,EAAOK,GACtBC,IACMF,IACV,CACD,EAUC3D,IAAc,OAChB,OAAOuD,EAAO,aAEhB,GAAIvD,IAAc,UAChB,OAAOuD,EAAO,gBAEZ,MAAWC,EAAK,UAAU,EAAG,CAC/B,MAAMM,EAAgBP,EAAOvD,GAC7B,IAAI+D,EAAmB,GACvB,GAAI,CAACD,EACI,YAET,IAAItF,EAAe,GAQf,GAPA,OAAOsF,GAAkB,UAERC,KACZvF,KAEPA,EAAOsF,EAAc,aAAa,KAEhC9C,EAAQ,YAAYxC,GAAO,CAEvB,SAAkBqC,EADAG,EAAQ,YAAYxC,GAAM,IACV,gBAAhBqC,cAA+B,QACvD,GAAI,CAACmD,EACH,MAAM,IAAI,MACR,wCAAwCxF,KAGtC,MAAE,OAAM,MAAS,IACjByF,EAASxB,iBAAM,OACrB,GAAI,CAACyB,GAAQ,CAACzB,GAAQ,CAACwB,EACrB,MAAM,IAAI,MACR,wCAAwCzF,KAGtC,QAAiB0F,EAAK,aAAa,WAAW,KAC9CC,EAAcH,EAAgB,KAC9BI,EAAUC,EAAiB,CAC/B,OAAQ5B,EAAK,OACb,SACA,aACD,EACKnB,EAAW2B,EAAW,mBAAmB,CAC7C,KAAMR,EAAK,OACX,WAAYQ,EAAW,cAAcqB,CAAc,EACpD,EACM,OACL,GAAGH,EACH,GAAGC,EACH,KAAMF,EAAK,aACX,GAAI1F,EACJ,WAAY+F,EAAM,aAAajD,EAAS,SAAS,EACnD,KAMI,eAAK,OAAL,cAAW,OAAX,QAAiB,OACAyC,MAErBZ,EAAa,KAAK,CAAE,GAAI3E,EAAM,kBAAkB,GACzC,IAEX,CACO,QACT,EACD,EACG,KAAa,OAAS,EAAG,CAE3B,MAAMgG,EAAcrB,EAAa,GACjC,MAAM,IAAIN,EACR,8CACA2B,EAAY,GACZA,EAAY,iBAEhB,CAGA,MAAMC,EAAW,WACjB,SAAUC,EAASC,EAAG,CACd,YAAa,IACnB,SAAUC,EAAeD,EAAGnG,EAAO,GAAI,CACjC,MAAO,IAAImG,CAAC,EAKhB,GAAO,IAAIA,CAAC,EACZ,QAASE,KAAK,OAAO,KAAKF,CAAC,EAAG,CACtB,QAAWnG,EAAK,OAAOqG,CAAC,EAC9B,KAAM,CAACA,EAAGF,EAAEE,GAAIC,EAAUH,CAAC,EACvBA,EAAEE,KAAO,MAAQ,OAAOF,EAAEE,IAAM,UAEhC,CACE,eACA,kBACA,OACAJ,GACA,SAASI,CAAC,IAGL,QAAeF,EAAEE,GAAIC,CAAQ,EAG1C,EACF,CACA,MAAOF,EAAeD,CAAC,CACzB,CACA,MAAMI,EAAY,GACT,QAACtF,EAAKkE,EAAOnF,EAAM0B,CAAM,IAAKwE,EAAStB,EAAQ,IAAI,EAC1D,GAAIO,WAAO,aAAc,CACvBoB,EAAU,KAAKvG,CAAI,EACnB,MAAMU,EAAS,GAKT8F,EAJUD,EAAU,OAAQE,GACzBzG,EAAK,KAAK,GAAG,EAAE,WAAWyG,EAAS,KAAK,GAAG,CAAC,CACpD,EAE6B,OAAO,SAAUC,EAAGC,EAAG,CACnD,OAAOD,EAAE,OAASC,EAAE,OAASD,EAAIC,EAClC,EACD,OAAO,KAAKxB,CAAK,EAAE,IAAKlE,GAAQ,CAE5B,IACE,aACA,eACA,kBACA,QACA,SAASA,CAAG,EAEP,SAETP,EAAOO,GAAO,CACZ,GAAGjB,EAAK,MAAMwG,EAAc,OAAS,CAAC,EACtCvF,GACA,KAAK,GAAG,EACX,EACDkE,EAAMc,GAAY,CAChB,GAAId,iBAAO,aAAa,KACxB,KAAMnF,EAAK,MAAMwG,EAAc,MAAM,EAAE,KAAK,GAAG,EAC/C,SACF,SAEA,OAAOrB,GAAU,UACjB,CAAC,MAAM,QAAQA,CAAK,GACpBA,IAAU,MAENlE,IAAQgF,EAAU,CACpB,MAAMW,EAAUL,EAAU,OAAQE,GACzBzG,EAAK,KAAK,GAAG,EAAE,WAAWyG,EAAS,KAAK,GAAG,CAAC,CACpD,EACD,GAAIG,EAAQ,OAAQ,CAClB,MAAMJ,EAAgBI,EAAQ,OAAO,SAAUF,EAAGC,EAAG,CACnD,OAAOD,EAAE,OAASC,EAAE,OAASD,EAAIC,EAClC,EAEKE,EADSC,GAAMlC,EAAQ,KAAM4B,EAAc,KAAK,GAAG,CAAC,EACxC,aAAa,KACzB9F,EAAS,GACf,OAAO,KAAKyE,CAAK,EAAE,IAAKlE,GAAQ,CAE5B,IACE,aACA,eACA,kBACA,QACA,SAASA,CAAG,EAEP,SAGTP,EAAOO,GAAO,CACZ,GAAGjB,EAAK,MAAMwG,EAAc,MAAM,EAClCvF,GACA,KAAK,GAAG,EACX,EACDkE,EAAMc,GAAY,CAChB,KACA,KAAMjG,EAAK,MAAMwG,EAAc,MAAM,EAAE,KAAK,GAAG,EAC/C,SAEJ,CACF,CAGG,OAAE,KAAM5B,EAAQ,KACzB,EACA,YAAa,MAAOpC,EAASE,IAAU,CAE/B,QAAS,MADFF,EAAQ,IAAI,IAAI,KACH,YACpBuE,EAAe3E,EAAQM,EAAM,MAAM,KAAK,EACxC,CAAE,kBAAmB,MAAMrD,GAAQ,CACvC,SACA,sBAAuB0H,EACxB,EACKrB,EAAQ,MAAMlD,EAAQ,IAAI,IAAI,KAAK,QACvCsC,EAAQ3C,CAAc,EACtB,CACE,UAAWO,EAAM,MAAM,SACzB,GAEIsE,EAAoB,GAE1B,YAAK,UAAUtB,EAAM,CAACzE,EAAKkE,KACrBA,WAAO,iBACT6B,EAAU,KAAK7B,CAAK,EAEfA,EACR,EACM,CACL,OACA,YACA,UAAWzC,EAAM,MAAM,UACvB,aAAcP,EACd,GAAIO,EAAM,MAAM,GAEpB,EACA,iBAAmBF,GAAY,CAACyE,EAAUC,IAAe,CACvD,MAAMtH,EAAS4C,EAAQ,IAAI,IAAI,KAAK,OACpC,OAAO,OAAOA,EAAQ,WAAW,EAAE,QAASH,GAAoB,WAC1D,IAACG,EAAQ,kBACPH,EAAgB,iBAClB,OAGJ,MAAMmD,GAAkBnD,IAAgB,IAAI,gBAApBA,cAAmC,QACrDyD,GACJhF,mBAAiB,OAAjB,cAAuB,aAAa,WAAW,KAE3C+B,EAAajD,EAAO,cACxBkG,GAAkB,IAEhBN,WAAiB,QACf2B,IAAW,KAAX,QAAe,OACjB3E,EAAQ,IAAI,QAAQ,IAClB,IAAI4E,GAAiB5B,EAAgB,IAAI,GAG3ChD,EAAQ,IAAI,MAAM,IAAIgD,EAAgB,IAAI,EAE9C,CACD,CACH,CACF,CACF,CACF,EACF,MAAMnB,UAAmB,KAAM,CAG7B,YAAYgD,EAAiBR,EAAYtB,EAA2B,CAClE,MAAM8B,CAAO,EACb,KAAK,KAAO,aACZ,KAAK,GAAKR,EACV,KAAK,iBAAmBtB,CAC1B,CACF,CAEA,MAAM+B,GAAc3F,GAA8B,CAC1C,QAAYC,EAAeD,CAAI,EAgBjC,GAfAE,EAAkBC,CAAS,GACzBA,EAAU,OAAS,QAIrBC,EAAcD,CAAS,GACXA,EAAU,WAEhB,MAAOH,GACJA,EAAK,gBAAgB,KAAMK,GAAUA,EAAM,OAAS,MAAM,CAClE,GAKDC,EAAeH,CAAS,GACtBA,EAAU,gBAAgB,KAAME,GAAUA,EAAM,OAAS,MAAM,EAC1D,QAGb,EAEM6D,EAAmB,CAAoC,CAC3D,SACA,SACA,YACF,IAImC,CACjC,MAAM0B,EAAiC,GAChC,iBAASjG,GAAU,CAClB,QAAImE,EAAOnE,EAAM,MACnB,OAAOkG,EAAM,KAGbA,IAAM,OAGJD,IAAM,MAAQE,GAAkB,CACpC,QACA,MAAOD,EACP,aACD,GACF,EACMD,CACT,EACME,GAAoB,CAAC,CACzB,QACA,QACA,YACF,IAIM,CACJ,OAAQnG,EAAM,KAAM,CAClB,IAAK,SAAU,CACb,GAAIA,EAAM,WACJA,EAAM,MACJ,MAAM,QAAQ6D,CAAK,EACd,SAAM,IAAKhF,GAAS,CACnB,QAAWmB,EAAM,UAAUnB,EAAK,WAClC,UAAO2C,GAAa,SAChB,UAAI,MAAM,gCAAgC,EAE3C,OACL,WAAYiD,EAAM,aAAajD,EAAS,SAAS,EACjD,GAAG+C,EAAiB,CAClB,OAAQ/C,EAAS,OACjB,OAAQ3C,EACR,aACD,EACH,CACD,EAOP,MAAMuH,EAAiBpG,EAAM,OACzB,UAAOoG,GAAmB,SACtB,UAAI,MAAM,gCAAgC,EAElD,GAAI,CAACA,EACH,MAAM,IAAI,MAAM,wCAAwCpG,EAAM,MAAM,EAEtE,GAAIA,EAAM,MACJ,SAAM,QAAQ6D,CAAK,EACd,SAAM,IAAKhF,IACT,CACL,WAAY4F,EAAM,aAAazE,EAAM,SAAS,EAC9C,GAAGuE,EAAiB,CAClB,OAAQ6B,EACR,OAAQvH,EACR,aACD,GAEJ,MAGI,QACL,WAAY4F,EAAM,aAAazE,EAAM,SAAS,EAC9C,GAAGuE,EAAiB,CAClB,OAAQ6B,EACR,OAAQvC,EACR,aACD,EAGP,CACA,QACS,QAEX,CACF,EC3qBawC,GACXC,GAIG,CACH,KAAM,CAACC,EAAaC,CAAc,EAAIC,EAAMC,SAA6B,IAAI,EAE7ED,SAAME,UAAU,IAAM,CAChBL,EAAMM,UAAUC,UACXC,wBAAiB,UAAY1F,GAAqC,CACnEA,EAAMgD,KAAK/D,OAAS,QACtBmG,EAAepF,EAAMgD,IAAI,CAC3B,CACD,EACM0C,wBAAiB,UAAY1F,GAAqC,eACnEA,mBAAOgD,OAAPhD,cAAaf,QAAS,gBAClBuG,oCAAWC,UAAXD,cAAoBG,gBAApBH,QAAmCI,YAAY,CACnD3G,KAAM,kBAEV,CACD,EAEF,GAACiG,EAAMM,UAAUC,OAAO,CAAC,IAG1B,OAAKI,UAAU,gBAAeC,SAC3BX,IACCY,EAACC,GAAY,CAEXxF,QAAS2E,EACTK,UAAWN,EAAMM,UACjB5E,gBAAiBsE,EAAMtE,eAHlBuE,IAAYhB,EAAE,IAMvB,UACEA,GAAG,cACH8B,IAAKf,EAAMM,UACXK,UAAU,2BACVK,IAAKhB,EAAMiB,IACX,GACE,CAEV,EAEMH,GAAgBd,GAIhB,CACJ,MAAMlE,EAAMoF,IAENC,EAAUhB,EAAMiB,QACpB,IACE5E,GAAa6E,YAAY,CACvB,GAAG9E,EACHT,MAIAJ,gBAAiBsE,EAAMtE,gBACxB,EACH,CAAE,GAGE,CAAC4F,EAAOC,CAAI,EAAIC,GAAWL,CAAO,EACxChB,SAAME,UAAU,IAAM,CACpB,MAAMoB,EAAyB3F,EAAI4F,OAAOC,UACvC,wBACU7G,IAEL8G,OAAOC,KAAKP,EAAM1G,QAAQkH,WAAW,EAAEC,SAASjH,EAAMkH,MAAM,GACzDT,GAAExH,KAAM,eAAgB,CAC/B,CACD,EAEGkI,EAAmBnG,EAAI4F,OAAOC,UAAW,cAAyB7G,IAClE8G,OAAOC,KAAKP,EAAM1G,QAAQkH,WAAW,EAAEC,SAASjH,EAAMkH,MAAM,GACzDT,GAAExH,KAAM,eAAgB,CAC/B,CACD,EAED,MAAO,IAAM,CACa0H,IACNQ,MAEnB,CAACnG,EAAKwF,EAAM1G,QAAQkH,WAAW,CAAC,EAEnC3B,EAAME,UAAU,IAAM,CAChBiB,EAAMY,QAAQ,gBAAgB,EAChCpG,EAAI4F,OAAOS,SAAS,CAAEpI,KAAM,iBAAkBwD,MAAO,WAAY,EACxD+D,EAAMY,QAAQ,uBAAuB,GAC9CpG,EAAI4F,OAAOS,SAAS,CAAEpI,KAAM,iBAAkBwD,MAAO,QAAS,CAChE,EACC,CAAC6E,KAAKC,UAAUf,EAAM/D,KAAK,CAAC,CAAC,EAEhC4C,EAAME,UAAU,IAAM,CAChBL,EAAMM,UAAUC,UACbgB,GAAExH,KAAM,iBAAkBwD,MAAOyC,EAAMM,UAAUC,QAAS,EAC3DP,EAAM1E,QAAQvB,OAAS,QACpBwH,GAAExH,KAAM,YAAawD,MAAOyC,EAAM1E,QAAS,EAE3CkF,wBAAiB,UAAY1F,GAAqC,CAEnEA,EAAMgD,KAAK/D,OAAS,SACjBwH,GAAExH,KAAM,eAAgB,CAC/B,CACD,EAEF,GAACiG,EAAMM,UAAUC,OAAO,CAAC,EAErB,IACT,EChIM+B,GAAI,oCAAY,MAAQ,oCAAY,uBAAyB,OAAQ/D,EAAI/C,GAAE,CAC/E,OAAQ8G,GACR,SAAU,oCAAY,UACtB,MAAO,IAAW,gCAAC,WACnB,MAAO,CACL,aAAc,QACd,aAAc,IACf,EACD,MAAO,CACL,KAAM,CACJ,UAAW,GACX,aAAc,IACf,CACF,EACD,OAAQ,CACN,YAAa,CACX,CACE,KAAM,OACN,MAAO,QACP,KAAM,SACN,OAAQ,KACR,OAAQ,CACN,CACE,KAAM,SACN,KAAM,QACN,MAAO,QACP,QAAS,GACT,SAAU,EACX,EACD,CACE,KAAM,YACN,KAAM,OACN,MAAO,OACP,OAAQ,EACT,CACF,CACF,EACD,CACE,KAAM,OACN,MAAO,QACP,KAAM,SACN,OAAQ,KACR,OAAQ,CACN,CACE,KAAM,SACN,KAAM,QACN,MAAO,QACP,QAAS,GACT,SAAU,EACX,EACD,CACE,KAAM,YACN,KAAM,OACN,MAAO,OACP,OAAQ,EACT,CACF,CACF,CACF,CACF,CACH,CAAC,qttBClDKC,GAAYpC,EAAMqC,KAAK,IAAMC,cAAO,uBAAqB,2DAEzDC,GAAoB1C,IACxB,KAAM,CAAC2C,EAASC,CAAU,EAAIzC,EAAMC,SAAS,EAAK,EAEhDS,SAACgC,EAAyBC,UAAS,CACjCH,UACAC,aAAuB,GACnB5C,EACJ+C,YACGC,oBAAQ,CAACC,WAAU,gBAAK,wBAA4B,aAClDV,GAAS,IAAKvC,EAAO4C,aAAwBD,UAAiB,EAAG,EAGtE,CAEN,EAEMO,GAAaA,CAAC,CAAEC,cAAuC,IAAM,CACjE,MAAMrH,EAAMoF,IACRkC,eAAMC,IAAI,eAAgBF,CAAY,EAE1CrH,EAAIhD,OAAOwK,IAAI,CACb,GAAGT,EACHC,UAAWJ,GACZ,EACM,IACT,EAEaa,GAAmBA,IAAM,CACpC,MAAMvL,EAAS,CAAE,GAAGwL,iBAAQxL,cAAQwL,GACpC,SAEGC,GAAO,IAAKD,EAAQxL,SAAgB0L,OAAQ,CAAEC,OAAQC,oFAAY,EAAEhD,UACnEC,EAACqC,GAAU,CAACC,aAAcK,EAAOK,MAAMV,aAAgB,EACvDtC,EAACiD,GAAS,CAACC,QAAShE,UAASyD,EAAgBQ,cAA0B,IAG7E,EAEMC,GAAWA,IAAM,CACf,MAAEC,WAAYC,GAAc,EAClCD,SAAQ,EAAI,IACL,gBAAK,uBAA0B,CACxC,EAEA,SAASE,IAAM,CACb,SACGC,GAAgB,CAACC,SAAUzD,EAAC0C,GAAoB,aAC/C1C,EAACoD,GAAQ,IACQ,CAEvB,CCtDAM,GAASC,OACNrE,IAAMsE,WAAU,UACf5D,EAACuD,GAAG,GAAG,GAETM,SAASC,eAAe,MAAM,CAAC","names":["relList","link","processPreload","mutations","mutation","node","getFetchOpts","script","fetchOpts","formify","blueprints","optimizedQuery","G.visit","optimizedDocumentNode","typeInfo","G.TypeInfo","schema","addMetaFields","metaFields","getPath","path","currentLevel","fieldPath","item","addBlueprints","_key","_parent","ancestors","nextInfo","innerNode","fields","G.visitWithTypeInfo","subInfo","_a","_b","result","items","key","groupedFields","groups","name","subFields","field","fieldAlias","fieldName","formifyVisitor","parent","type","G.getNamedType","G.isInterfaceType","namedType","G.isUnionType","intfc","G.isObjectType","blueprintVisitor","formifiedQuery","G.parse","documentMachine","createMachine","sendParent","context","_context","event","assign","tina","collection","template","resolvedForm","resolveForm","onSubmit","payload","mutationString","e","formConfig","formifyCallback","buildForm","args","generateFormCreators","cms","showInSidebar","Form","options","SKIPPED","skipped","skip","form","createForm","initialContext","queryMachine","QueryError","doc","spawn","existingData","tinaSchema","gqlSchema","missingForms","newData","G.graphql","G.print","source","info","aliases","fieldNode","value","alias","aliasValue","existingValue","skipFormRegister","documentContext","values","data","extraValues","formVal","resolveFormValue","collectionName","NAMER","missingForm","META_KEY","traverse","o","innerTraversal","i","itemPath","nodePaths","nearestParent","nodePath","a","b","parents","id","getIn","documentNode","documents","callback","_onReceive","_c","GlobalFormPlugin","message","isNodeType","accum","v","resolveFieldValue","templateFields","Preview","props","activeQuery","setActiveQuery","React","useState","useEffect","iframeRef","current","addEventListener","contentWindow","postMessage","className","children","_jsx","QueryMachine","ref","src","url","useCMS","machine","useMemo","withContext","state","send","useMachine","unsubscribeFieldChange","events","subscribe","Object","keys","documentMap","includes","formId","unsubscribeReset","matches","dispatch","JSON","stringify","t","RawEditor","lazy","__vitePreload","Editor","rawMode","setRawMode","MdxFieldPluginExtendible","Component","rawEditor","Suspense","fallback","SetPreview","outputFolder","flags","set","add","TinaAdminWrapper","config","TinaCMS","client","apiUrl","__API_URL__","build","TinaAdmin","preview","schemaJson","GoToEdit","setEdit","useEditState","App","TinaEditProvider","editMode","ReactDOM","render","StrictMode","document","getElementById"],"sources":["../../vite/modulepreload-polyfill","../../.tina/__generated__/app/src/lib/formify/index.ts","../../.tina/__generated__/app/src/lib/machines/document-machine.ts","../../.tina/__generated__/app/src/lib/machines/query-machine.ts","../../.tina/__generated__/app/src/preview.tsx","../../.tina/__generated__/prebuild/config.js","../../.tina/__generated__/app/src/App.tsx","../../.tina/__generated__/app/src/main.tsx"],"sourcesContent":["__VITE_IS_MODERN__&&(function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n}());","/**\n\n*/\n\nimport * as G from 'graphql'\n\ntype VisitorType = G.Visitor<G.ASTKindToNode, G.ASTNode>\ntype Info = { name: string; alias: string; fields?: Info[]; path?: string[] }\nexport type Blueprint2 = Info\n\nexport const formify = async ({\n  schema,\n  optimizedDocumentNode,\n}: {\n  schema: G.GraphQLSchema\n  optimizedDocumentNode: G.DocumentNode\n}): Promise<{\n  formifiedQuery: G.DocumentNode\n  blueprints: Blueprint2[]\n}> => {\n  const blueprints: Blueprint2[] = []\n  const visitor: VisitorType = {\n    OperationDefinition: (node) => {\n      if (!node.name) {\n        return {\n          ...node,\n          name: {\n            kind: 'Name',\n            // FIXME: add some sort of uuid to this\n            value: `QueryOperation`,\n          },\n        }\n      }\n      return node\n    },\n  }\n  const documentNodeWithName = G.visit(optimizedDocumentNode, visitor)\n  const optimizedQuery = documentNodeWithName as G.DocumentNode\n  const typeInfo = new G.TypeInfo(schema)\n\n  const addMetaFields: G.VisitFn<G.ASTNode, G.FieldNode> = (\n    node: G.FieldNode\n  ): G.ASTNode => {\n    return {\n      ...node,\n      selectionSet: {\n        ...(node.selectionSet || {\n          kind: 'SelectionSet',\n          selections: [],\n        }),\n        selections:\n          [...(node.selectionSet?.selections || []), ...metaFields] || [],\n      },\n    }\n  }\n\n  const getPath = (\n    path: readonly (string | number)[],\n    node: G.ASTNode | readonly G.ASTNode[]\n  ) => {\n    let currentLevel = node\n    const fieldPath: string[] = []\n    path.forEach((item) => {\n      // @ts-ignore not sure the best way to ensure this is indexable\n      currentLevel = currentLevel[item]\n      if (!Array.isArray(currentLevel)) {\n        // @ts-ignore FIXME this array check doesn't seem to be doing anything for the types\n        if (currentLevel.kind === 'Field') {\n          fieldPath.push(currentLevel.name.value)\n        }\n      }\n    })\n    return fieldPath\n  }\n\n  const addBlueprints: G.VisitFn<G.ASTNode, G.FieldNode> = (\n    node: G.FieldNode,\n    _key,\n    _parent,\n    path,\n    ancestors\n  ): void => {\n    const fieldPath = getPath(path, ancestors[0])\n    const nextInfo = (innerNode: G.FieldNode) => {\n      const fields: Info['fields'] = []\n      G.visit(\n        innerNode,\n        G.visitWithTypeInfo(typeInfo, {\n          Field: {\n            enter: (node) => {\n              typeInfo.enter(node)\n              if (node.name.value !== innerNode.name.value) {\n                if (node.selectionSet?.selections.length) {\n                  const subInfo = nextInfo(node)\n                  fields.push({\n                    name: node.name.value,\n                    alias: node.alias?.value || node.name.value,\n                    fields: subInfo.fields,\n                  })\n                  // Stop visiting this subtree, it'll be visited from the next nextInfo() call\n                  return false\n                } else {\n                  fields.push({\n                    name: node.name.value,\n                    alias: node.alias?.value || node.name.value,\n                  })\n                }\n              }\n            },\n            leave: (node) => {\n              typeInfo.leave(node)\n            },\n          },\n        })\n      )\n      if (fields?.length) {\n        return {\n          name: innerNode.name.value,\n          alias: innerNode.alias?.value || innerNode.name.value,\n          fields,\n        }\n      } else {\n        return {\n          name: innerNode.name.value,\n          alias: innerNode.alias?.value || innerNode.name.value,\n        }\n      }\n    }\n    const result = nextInfo(node)\n    const mergeFields = (fields: Info['fields']): Info['fields'] => {\n      if (!fields) {\n        return []\n      }\n      const groupBy = <T extends { [key: string]: any }>(\n        items: T[],\n        key: string\n      ) =>\n        items.reduce(\n          (result: { [key: string]: T[] }, item: T) => ({\n            ...result,\n            [item[key]]: [...(result[item[key]] || []), item],\n          }),\n          {}\n        )\n\n      const groups = groupBy(fields, 'alias') as { [name: string]: Info[] }\n      const groupedFields: Info[] = []\n      Object.entries(groups).forEach(([name, items]) => {\n        const subFields: Info[] = []\n        items.forEach((item) => {\n          item.fields?.forEach((field) => subFields.push(field))\n        })\n        const fieldName = items[0].name\n        const fieldAlias = items[0].alias\n        if (subFields?.length) {\n          groupedFields.push({\n            name: fieldName,\n            alias: fieldAlias,\n            fields: subFields,\n          })\n        } else {\n          groupedFields.push({ name: fieldName, alias: fieldAlias })\n        }\n      })\n      return groupedFields\n    }\n    const fields = mergeFields(result.fields)\n    if (\n      // blueprints.find(({ path }) =>\n      //   fieldPath.join('.').startsWith(path.join('.'))\n      // )\n      false\n    ) {\n      // skip because this is a nested blueperint\n    } else {\n      if (fields?.length) {\n        blueprints.push({\n          name: result.name,\n          alias: result.alias,\n          fields,\n          path: fieldPath,\n        })\n      } else {\n        blueprints.push({\n          name: result.name,\n          alias: result.alias,\n          path: fieldPath,\n        })\n      }\n    }\n  }\n\n  const formifyVisitor: VisitorType = {\n    InlineFragment: {\n      enter: (node) => {\n        typeInfo.enter(node)\n      },\n      leave: (node) => {\n        typeInfo.leave(node)\n      },\n    },\n    Field: {\n      enter: (node, key, parent, path, ancestors) => {\n        typeInfo.enter(node)\n        const type = typeInfo.getType()\n        if (type) {\n          const namedType = G.getNamedType(type)\n          if (G.isInterfaceType(namedType)) {\n            if (namedType.name === 'Node') {\n              return addMetaFields(node, key, parent, path, ancestors)\n            }\n          }\n          if (G.isUnionType(namedType)) {\n            const types = namedType.getTypes()\n            if (\n              types.every((type) => {\n                return type\n                  .getInterfaces()\n                  .some((intfc) => intfc.name === 'Node')\n              })\n            ) {\n              return addMetaFields(node, key, parent, path, ancestors)\n            }\n          }\n          if (G.isObjectType(namedType)) {\n            if (\n              namedType.getInterfaces().some((intfc) => intfc.name === 'Node')\n            ) {\n              return addMetaFields(node, key, parent, path, ancestors)\n            }\n          }\n        }\n      },\n    },\n  }\n  const blueprintVisitor: VisitorType = {\n    InlineFragment: {\n      enter: (node) => {\n        typeInfo.enter(node)\n      },\n      leave: (node) => {\n        typeInfo.leave(node)\n      },\n    },\n    Field: {\n      enter: (node, key, parent, path, ancestors) => {\n        typeInfo.enter(node)\n        const type = typeInfo.getType()\n        if (type) {\n          const namedType = G.getNamedType(type)\n          if (G.isInterfaceType(namedType)) {\n            if (namedType.name === 'Node') {\n              addBlueprints(node, key, parent, path, ancestors)\n              return false\n            }\n          }\n          if (G.isUnionType(namedType)) {\n            const types = namedType.getTypes()\n            if (\n              types.every((type) => {\n                return type\n                  .getInterfaces()\n                  .some((intfc) => intfc.name === 'Node')\n              })\n            ) {\n              addBlueprints(node, key, parent, path, ancestors)\n              return false\n            }\n          }\n          if (G.isObjectType(namedType)) {\n            if (\n              namedType.getInterfaces().some((intfc) => intfc.name === 'Node')\n            ) {\n              addBlueprints(node, key, parent, path, ancestors)\n              return false\n            }\n          }\n        }\n      },\n    },\n  }\n  const formifiedQuery = G.visit(\n    optimizedQuery,\n    G.visitWithTypeInfo(typeInfo, formifyVisitor)\n  )\n  G.visit(formifiedQuery, G.visitWithTypeInfo(typeInfo, blueprintVisitor))\n\n  return { formifiedQuery, blueprints }\n}\n\n/**\n * This is a dummy query which we pull apart and spread\n * back into the the selectionSet for all \"Node\" fields\n */\nconst node = G.parse(`\n query Sample {\n  ...on Document {\n    _internalValues: _values\n    _internalSys: _sys {\n      breadcrumbs\n      basename\n      filename\n      path\n      extension\n      relativePath\n      title\n      template\n      collection {\n        name\n        slug\n        label\n        path\n        format\n        matches\n        templates\n        fields\n        __typename\n      }\n      __typename\n    }\n  }\n }`)\nconst metaFields: G.SelectionNode[] =\n  // @ts-ignore\n  node.definitions[0].selectionSet.selections\n","/**\n\n*/\nimport { Client, Field, Form, FormOptions, TinaCMS } from 'tinacms'\nimport { assign, createMachine, sendParent } from 'xstate'\nimport {\n  resolveForm,\n  Templateable,\n  TinaFieldEnriched,\n  TinaSchema,\n} from 'tinacms'\n\nexport type FieldType = Field & TinaFieldEnriched\nexport type FormValues = Record<string, unknown>\nexport type FormType = Form<FormValues, FieldType>\n\nexport type DataType = Record<string, unknown>\n\nexport type Data = {\n  _internalValues: object\n  _internalSys: {\n    breadcrumbs: string[]\n    basename: string\n    filename: string\n    path: string\n    extension: string\n    relativePath: string\n    title?: string\n    template: string\n    collection: {\n      name: string\n      slug: string\n      label: string\n      path: string\n      format: string\n      matches?: string\n      templates?: object\n      fields?: object\n      __typename: string\n    }\n  }\n}\n\ntype ContextType = {\n  id: string\n  data: null | Data\n  form: null | FormType\n  cms: TinaCMS\n  formifyCallback: (args: any, cms: TinaCMS) => Form\n}\n\nexport const documentMachine =\n  /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOgNwBdd0AbXALwKgGIIB7Qs-ANzYGswJNFjyFS5KrQZMEBXpnRUOAbQAMAXUSgADm1iVcHLSAAeiAEwAWSyUsA2VQE4AzAHYArABoQAT0QAORxJHEMdLd1d7d3NXWIBfOO9hHAJiLgMpRnwWMAAnXLZckm0aRQAzQtQhDBSxdMk6LKhZHjYFJXw1TSQQXX0O4zMEKxt7JzcvXwtVd2DQu2d-ZwBGVWX-dwTEkHw2CDhjZNE0iWpGpmM+gyMeoctzbz8EVaDLUNdAtfvIze2j1NIuTA6AgTx0emu+EGiEszlUtlcdncdnMkyey3WtlC-mWjmW7ncTlRCSSNWOpDyBVylwhA1uMLhCKRKLRFlxcxC4UiSJikRJIH+Yhp-UMUPpz38j0Q6y2cSAA */\n  createMachine(\n    {\n      tsTypes: {} as import('./document-machine.typegen').Typegen0,\n      schema: {\n        context: {} as ContextType,\n        services: {} as {\n          initializer: {\n            data: {\n              form: FormType | undefined\n              data: Data\n            }\n          }\n          scanner: {\n            data: {\n              data: object\n            }\n          }\n        },\n        events: {} as\n          | {\n              type: 'ADD_LOCATION'\n              value: string\n            }\n          | {\n              type: 'INIT'\n            }\n          | {\n              type: 'SCAN'\n            }\n          | {\n              type: 'RESCAN'\n            },\n      },\n      id: '(machine)',\n      initial: 'initializing',\n      states: {\n        initializing: {\n          invoke: {\n            src: 'initializer',\n            onDone: [\n              {\n                actions: ['storeFormAndData', 'notifyParent'],\n                target: 'ready',\n              },\n            ],\n            onError: [\n              {\n                actions: 'handleError',\n                target: 'error',\n              },\n            ],\n          },\n        },\n        ready: {},\n        error: {},\n      },\n    },\n    {\n      actions: {\n        notifyParent: sendParent((context) => {\n          return {\n            type: 'DOCUMENT_READY',\n            value: context.id,\n          }\n        }),\n        handleError: (_context, event) => {\n          console.error(event.data)\n        },\n        storeFormAndData: assign((context, event) => {\n          // context.cms.forms.add(event.data.form)\n          return { ...context, form: event.data.form, data: event.data.data }\n        }),\n      },\n      services: {\n        initializer: async (context) => {\n          const tina = context.cms.api.tina as Client\n          let node: Data\n          if (context.data) {\n            node = context.data\n          } else {\n            const response = await tina.request<{\n              node: Data\n            }>(\n              `query GetNode($id: String!) {\n        node(id: $id) {\n          ...on Document {\n            _internalValues: _values\n            _internalSys: _sys {\n              breadcrumbs\n              basename\n              filename\n              path\n              extension\n              relativePath\n              title\n              template\n              collection {\n                name\n                slug\n                label\n                path\n                format\n                matches\n                templates\n                fields\n                __typename\n              }\n              __typename\n            }\n          }\n        }\n      }`,\n              { variables: { id: context.id } }\n            )\n            node = response.node\n          }\n          const schema = context.cms.api.tina.schema as TinaSchema\n          if (!schema) {\n            throw new Error(`Schema must be provided`)\n          }\n          const collection = schema.getCollection(\n            node._internalSys.collection.name\n          )\n          let template: Templateable\n          if (collection.templates) {\n            template = collection.templates.find((template) => {\n              if (typeof template === 'string') {\n                throw new Error(`Global templates not supported`)\n              }\n              return template.name === node._internalSys.template\n            }) as Templateable\n          } else {\n            template = collection\n          }\n          if (!template) {\n            throw new Error(\n              `Unable to find template for node ${node._internalSys.path}`\n            )\n          }\n          const resolvedForm = resolveForm({\n            collection,\n            basename: node._internalSys.filename,\n            schema,\n            template,\n          })\n          const onSubmit = async (payload: Record<string, unknown>) => {\n            try {\n              const mutationString = `#graphql\n              mutation UpdateDocument($collection: String!, $relativePath: String!, $params: DocumentUpdateMutation!) {\n                updateDocument(collection: $collection, relativePath: $relativePath, params: $params) {\n                  __typename\n                }\n              }\n            `\n\n              await context.cms.api.tina.request(mutationString, {\n                variables: {\n                  collection: node._internalSys.collection.name,\n                  relativePath: node._internalSys.relativePath,\n                  params: schema.transformPayload(\n                    node._internalSys.collection.name,\n                    payload\n                  ),\n                },\n              })\n              context.cms.alerts.success('Document saved!')\n            } catch (e) {\n              context.cms.alerts.error(\n                'There was a problem saving your document'\n              )\n              console.error(e)\n            }\n          }\n          const formConfig = {\n            id: context.id,\n            label:\n              node._internalSys.title || node._internalSys.collection.label,\n            initialValues: node._internalValues,\n            fields: resolvedForm.fields,\n            onSubmit,\n          }\n          const formifyCallback = context.formifyCallback\n          const form = buildForm(\n            formConfig,\n            context.cms,\n            (args) => {\n              if (formifyCallback) {\n                return formifyCallback(args, context.cms)\n              } else {\n                return args.createForm(args.formConfig)\n              }\n            },\n            true,\n            onSubmit\n          )\n          return { form, data: node }\n        },\n      },\n    }\n  )\n\ntype FormCreator = (formConfig: FormOptions<any>) => Form\ninterface GlobalFormOptions {\n  icon?: any\n  layout: 'fullscreen' | 'popup'\n}\ntype GlobalFormCreator = (\n  formConfig: FormOptions<any>,\n  options?: GlobalFormOptions\n) => Form\ninterface GlobalFormOptions {\n  icon?: any\n  layout: 'fullscreen' | 'popup'\n}\nexport interface FormifyArgs {\n  formConfig: FormOptions<any>\n  createForm: FormCreator\n  createGlobalForm: FormCreator\n  skip?: () => void\n}\n\nexport type formifyCallback = (args: FormifyArgs, cms: TinaCMS) => Form | void\nexport type onSubmitArgs = {\n  /**\n   * @deprecated queryString is actually a mutation string, use `mutationString` instead\n   */\n  queryString: string\n  mutationString: string\n  variables: object\n}\n\nexport const generateFormCreators = (cms: TinaCMS, showInSidebar?: boolean) => {\n  const createForm = (formConfig: FormOptions<any, any>) => {\n    return new Form(formConfig)\n  }\n  const createGlobalForm: GlobalFormCreator = (\n    formConfig,\n    options?: { icon?: any; layout: 'fullscreen' | 'popup' }\n  ) => {\n    const form = new Form({\n      ...formConfig,\n      global: { global: true, ...options },\n    })\n    return form\n  }\n  return { createForm, createGlobalForm }\n}\n\nexport const buildForm = (\n  formConfig: any,\n  cms: TinaCMS,\n  formify: formifyCallback,\n  showInSidebar: boolean = false,\n  onSubmit?: (args: any) => void\n): FormType | undefined => {\n  const { createForm, createGlobalForm } = generateFormCreators(\n    cms,\n    showInSidebar\n  )\n  const SKIPPED = 'SKIPPED'\n  let form\n  let skipped\n  const skip = () => {\n    skipped = SKIPPED\n  }\n  if (skipped) return\n\n  if (formify) {\n    form = formify(\n      {\n        formConfig,\n        createForm,\n        createGlobalForm,\n        skip,\n      },\n      cms\n    )\n  } else {\n    form = createForm(formConfig)\n  }\n\n  if (!(form instanceof Form)) {\n    if (skipped === SKIPPED) {\n      return\n    }\n    throw new Error('formify must return a form or skip()')\n  }\n\n  return form\n}\n","/**\n\n*/\nimport { assign, createMachine, spawn } from 'xstate'\nimport {\n  Form,\n  TinaCMS,\n  NAMER,\n  TinaFieldEnriched,\n  TinaCollection,\n  TinaSchema,\n  GlobalFormPlugin,\n  Client,\n} from 'tinacms'\nimport * as G from 'graphql'\nimport { formify } from '../formify'\nimport { Data, documentMachine } from './document-machine'\nimport type { ActorRefFrom } from 'xstate'\nimport { getIn } from 'final-form'\n\nexport type DataType = Record<string, unknown>\ntype DocumentInfo = {\n  ref: ActorRefFrom<typeof documentMachine>\n}\ntype DocumentMap = {\n  [documentId: string]: DocumentInfo & {\n    /** We don't support nested forms or forms for list queries */\n    skipFormRegister: boolean\n  }\n}\n\ntype ContextType = {\n  id: null | string\n  data: null | DataType\n  cms: TinaCMS\n  documentNode: G.DocumentNode\n  variables: object\n  iframe: null | HTMLIFrameElement\n  registerSubForms?: boolean\n  formifyCallback: (args: any) => Form\n  documentMap: DocumentMap\n  documents: Data[]\n}\nexport const initialContext: Omit<ContextType, 'cms' | 'formifyCallback'> = {\n  id: null,\n  data: null,\n  variables: {},\n  documentMap: {},\n  documents: [],\n  documentNode: { kind: 'Document', definitions: [] },\n  iframe: null,\n}\nexport const queryMachine =\n  /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOgFcAnAGxNwirAGIBlAUQBUB9AVQCUAZRKAAOAe1i4ALrlH4hIAB6IAjAAYALCXXqAnACZVAVmUAOAGxmAzMp1mANCACeidXpMkdnnSZvLDh1X11AF9ghzQsPEJSSho6BhYOTgBJADkABW4uPkEkEDEJaVl5JQQAdh0SMtVqvTqassN1M0MHZwRLdWUPLx8dPwCg0PCMHAJicmpaeiY2LgARZOZ0-gBBAE0eAXkCqRk5PNKyvRJVM-OL8+U2xD0mns8+gcC9ELCQCLHoybiZxm50vNVuxWFtciJxHtiodECZKqoLOpVMpjiYTGUyp0bghlGYyg9vL5-C83iNIuNSMJcMIwFRxtMEqt5vNOABFbisXjrHaQooHUBHPSWEiGSw6VSWUWYvRWHTYsro07nSzIpE+CrDD6jKITKk0umEBmzbgAIXmAHkAMLcACyrFS7GYPMK+xKiGOwtF4sllmlsuxOlcIquJlUJm04pMms+Osp1Np9PiTGSADFeKs7ZwbebuA7WPNnVD+YpEKKzCKFWG0dZkSZWk5YRKlWdDMc8f5SVryd89QnDQQ9ug6QAvAhQRgQWRgWj4ABuogA1tOYxSSL2DdOB9Ih7hR-goAgCPPMOg+QBtVQAXULfLdOLU+Neej8yksNdM9faCs0l3FrleorRtqq7rom+CDiOY6MGAFAUKIFBrlQp4AGbwagJArj28YbjOEG7mOh5zqIJ7nleN6ujC941CQT4vm+agftiZg6Piv4aHU6iAe8mG6th9IAO7oHs+6MBa1p2g6nC8KwTLcnkuy3pRygPjRrh0e+dbYspujNmcf4cU0QHdrx+r0jS+AQFBk79kRS4YcBWGmYa5mWfuhHHqe+wXte8m8hRAoqKYmiSn4Mr0bWn4qJYipeJ4gSto0zRGV8Jl9tOLlQTBcEIcISGSKhFDoTxcZOelYAWQRR7EZ5sjeeR0IBVRj5qcY4WMQ2OIIicbH-pxnbFWufGGhQYDoBAjj-ICwKgjk9XFqUlh4iQnS+kiOgJU09gdfo5YXCqyhqiiOjJbGg2lSQI1jRN0nZgAaqC7KcnJEIug1JYdEtK1lGtG3NNi6LuBc6gmHUophmUJ0gUN06XeNiT8KwloLFatr2uwc13sphgijYooJcpdRmCYWnKeWsXiutGKbZDjlpRdo1wymySsPwLKWgAEqsqQAOKsBjlGLfiX0-VTf0dcoMruIYoTvPgogQHA8gDbERr841ynuDK63WHclyWNihgGASTzEvoNMTLEavvcDumXBcB0Btj5PxaLZh6ObJV00mVulE02Nu7oROSs+XR6P9626a2MqNIZ3EOalOFbrgO57lAPuIH+VQ+M+0UaZF5SGLt5xR+2sdkilns4YJwlp75r3zRn3inDovoaAq6LSiTb4kCYb4qvoBh4sdcfGZXZnla5tcvUWmO+t0am99WDGaeL1juAqraGCDRg2O7I8V2ddOw+00+KY1GJaQY7jO5TiVmB7h84Vl8Hpzic9aM+i+98v+dlGoBIU1+vffep1QKEFfqKJidxdKmDDBGBEHtX6vFtnbM4DsOpCgAeTXowDQhAA */\n  createMachine(\n    {\n      tsTypes: {} as import('./query-machine.typegen').Typegen0,\n      schema: {\n        context: {} as ContextType,\n        services: {} as {\n          initializer: {\n            data: {\n              data: DataType\n            }\n          }\n          setter: {\n            data: { data: DataType }\n          }\n          subDocumentResolver: {\n            data: {\n              id: string\n              location: string\n            }[]\n          }\n          onChangeCallback: {\n            data: undefined\n          }\n        },\n        events: {} as\n          | {\n              type: 'IFRAME_MOUNTED'\n              value: HTMLIFrameElement\n            }\n          | {\n              type: 'SELECT_DOCUMENT'\n              value: string\n            }\n          | {\n              type: 'DOCUMENT_READY'\n              value: string\n            }\n          | {\n              type: 'NAVIGATE'\n            }\n          | {\n              type: 'ADD_QUERY'\n              value: {\n                id: string\n                type: 'open' | 'close'\n                query: string\n                data: object\n                variables: object\n              }\n            }\n          | {\n              type: 'REMOVE_QUERY'\n              value: string\n            }\n          | {\n              type: 'SUBDOCUMENTS'\n              value: { id: string; location: string }[]\n            }\n          | {\n              type: 'FIELD_CHANGE'\n            }\n          | {\n              type: 'EDIT_MODE'\n            },\n      },\n      id: '(machine)',\n      type: 'parallel',\n      states: {\n        pipeline: {\n          initial: 'idle',\n          states: {\n            idle: {\n              entry: 'clear',\n              on: {\n                ADD_QUERY: {\n                  target: 'initializing',\n                },\n                SUBDOCUMENTS: {\n                  target: 'pending',\n                },\n                IFRAME_MOUNTED: {\n                  actions: 'setIframe',\n                },\n              },\n            },\n            initializing: {\n              invoke: {\n                src: 'initializer',\n                onDone: [\n                  {\n                    actions: 'storeInitialValues',\n                    target: 'pending',\n                  },\n                ],\n                onError: [\n                  {\n                    actions: 'handleError',\n                    target: 'error',\n                  },\n                ],\n              },\n            },\n            waiting: {\n              on: {\n                DOCUMENT_READY: {\n                  target: 'pending',\n                },\n              },\n            },\n            pending: {\n              invoke: {\n                src: 'setter',\n                onDone: [\n                  {\n                    target: 'ready',\n                  },\n                ],\n                onError: [\n                  {\n                    actions: 'handleMissingDocument',\n                    target: 'waiting',\n                  },\n                ],\n              },\n            },\n            ready: {\n              entry: 'resolveData',\n              invoke: {\n                src: 'onChangeCallback',\n              },\n              on: {\n                NAVIGATE: {\n                  target: 'idle',\n                },\n                REMOVE_QUERY: {\n                  target: 'idle',\n                },\n                FIELD_CHANGE: {\n                  target: 'pending',\n                },\n              },\n            },\n            error: {},\n          },\n        },\n      },\n    },\n    {\n      actions: {\n        handleError: (_context, event) => console.error(event.data),\n        handleMissingDocument: assign((context, event) => {\n          if (event.data instanceof QueryError) {\n            if (context.documentMap[event.data.id]) {\n              // Already exists\n              return context\n            }\n            if (!event.data.id) {\n              return context\n            }\n            const existingData = context.documents.find(\n              (doc) => doc._internalSys.path === event.data.id\n            )\n            const doc = {\n              ref: spawn(\n                documentMachine.withContext({\n                  id: event.data.id,\n                  cms: context.cms,\n                  formifyCallback: context.formifyCallback,\n                  form: null,\n                  data: existingData || null,\n                })\n              ),\n            }\n\n            return {\n              ...context,\n              documentMap: {\n                ...context.documentMap,\n                [event.data.id]: {\n                  ...doc,\n                  skipFormRegister: event.data.skipFormRegister,\n                },\n              },\n            }\n          } else {\n            console.error(event.data)\n            return context\n          }\n        }),\n        clear: assign((context) => {\n          context.cms.forms.all().forEach((form) => {\n            context.cms.forms.remove(form.id)\n          })\n          return {\n            ...initialContext,\n            formifyCallback: context.formifyCallback,\n            cms: context.cms,\n            // documentMap: context.documentMap, // to preserve docs across pages\n            iframe: context.iframe,\n          }\n        }),\n        storeInitialValues: assign((context, event) => {\n          return {\n            ...context,\n            ...event.data,\n          }\n        }),\n        setIframe: assign((context, event) => {\n          return {\n            ...context,\n            iframe: event.value,\n          }\n        }),\n        resolveData: assign((context, event) => {\n          if (context.iframe) {\n            context.iframe?.contentWindow?.postMessage({\n              type: 'updateData',\n              id: context.id,\n              data: event.data.data,\n            })\n          }\n          return {\n            ...context,\n            data: event.data.data,\n          }\n        }),\n      },\n      services: {\n        setter: async (context) => {\n          const tinaSchema = context.cms.api.tina.schema as TinaSchema\n          const gqlSchema = context.cms.api.tina.gqlSchema\n          const missingForms: { id: string; skipFormRegister: boolean }[] = []\n          const newData = await G.graphql({\n            schema: gqlSchema,\n            source: G.print(context.documentNode),\n            rootValue: context.data,\n            variableValues: context.variables,\n            fieldResolver: (source, args, _context, info) => {\n              const fieldName = info.fieldName\n\n              /**\n               * Since the `source` for this resolver is the query that\n               * ran before passing it into `useTina`, we need to take aliases\n               * into consideration, so if an alias is provided we try to\n               * see if that has the value we're looking for. This isn't a perfect\n               * solution as the `value` gets overwritten depending on the alias\n               * query.\n               */\n              const aliases: string[] = []\n              info.fieldNodes.forEach((fieldNode) => {\n                if (fieldNode.alias) {\n                  aliases.push(fieldNode.alias.value)\n                }\n              })\n              let value = source[fieldName]\n              if (!value) {\n                aliases.forEach((alias) => {\n                  const aliasValue = source[alias]\n                  if (aliasValue) {\n                    value = aliasValue\n                  }\n                })\n              }\n              /**\n               * Formify adds `_internalSys` and `_internalValues` to the query\n               * and a user's query might also include `_values` or `_sys`, but\n               * it may not contain all of the info we need, so the actual\n               * source of truth for these values is our alias ones, which are\n               * also guaranteed to include all of the values another `_sys` query\n               * might include\n               */\n              if (fieldName === '_sys') {\n                return source._internalSys\n              }\n              if (fieldName === '_values') {\n                return source._internalValues\n              }\n              if (isNodeType(info.returnType)) {\n                const existingValue = source[fieldName]\n                let skipFormRegister = false\n                if (!existingValue) {\n                  return null\n                }\n                let path: string = ''\n                if (typeof existingValue === 'string') {\n                  // this is a reference value (eg. post.author)\n                  skipFormRegister = true\n                  path = existingValue\n                } else {\n                  path = existingValue._internalSys.path\n                }\n                if (context.documentMap[path]) {\n                  const documentMachine = context.documentMap[path].ref\n                  const documentContext = documentMachine.getSnapshot()?.context\n                  if (!documentContext) {\n                    throw new Error(\n                      `Document not set up properly for id: ${path}`\n                    )\n                  }\n                  const { data, form } = documentContext\n                  const values = form?.values\n                  if (!data || !form || !values) {\n                    throw new Error(\n                      `Document not set up properly for id: ${path}`\n                    )\n                  }\n                  const collectionName = data._internalSys.collection.name\n                  const extraValues = documentContext.data\n                  const formVal = resolveFormValue({\n                    fields: form.fields,\n                    values: values,\n                    tinaSchema,\n                  })\n                  const template = tinaSchema.getTemplateForData({\n                    data: form.values,\n                    collection: tinaSchema.getCollection(collectionName),\n                  })\n                  return {\n                    ...extraValues,\n                    ...formVal,\n                    _sys: data._internalSys,\n                    id: path,\n                    __typename: NAMER.dataTypeName(template.namespace),\n                  }\n                } else {\n                  // TODO: when we support forms in lists, remove this check\n                  // This checks that we're at least 2 levels deep, meaning top-level\n                  // queries list page(relativePath: '...') will be registered, but\n                  // not connection nodes like pageConnection.edges.node\n                  if (info.path?.prev?.prev) {\n                    skipFormRegister = true\n                  }\n                  missingForms.push({ id: path, skipFormRegister })\n                  return null\n                }\n              }\n              return value\n            },\n          })\n          if (missingForms.length > 0) {\n            // Only run this one at a time\n            const missingForm = missingForms[0]\n            throw new QueryError(\n              `Unable to resolve form for initial document`,\n              missingForm.id,\n              missingForm.skipFormRegister\n            )\n          }\n          // Populate __meta__ property for use\n          // in active field indicator utility\n          const META_KEY = '__meta__'\n          function* traverse(o) {\n            const memory = new Set()\n            function* innerTraversal(o, path = []) {\n              if (memory.has(o)) {\n                // we've seen this object before don't iterate it\n                return\n              }\n              // add the new object to our memory.\n              memory.add(o)\n              for (let i of Object.keys(o)) {\n                const itemPath = path.concat(i)\n                yield [i, o[i], itemPath, o]\n                if (o[i] !== null && typeof o[i] == 'object') {\n                  if (\n                    [\n                      '_internalSys',\n                      '_internalValues',\n                      '_sys',\n                      META_KEY,\n                    ].includes(i)\n                  ) {\n                    //going one step down in the object tree!!\n                    yield* innerTraversal(o[i], itemPath)\n                  }\n                }\n              }\n            }\n            yield* innerTraversal(o)\n          }\n          const nodePaths = []\n          for (let [key, value, path, parent] of traverse(newData.data)) {\n            if (value?._internalSys) {\n              nodePaths.push(path)\n              const fields = {}\n              const parents = nodePaths.filter((nodePath) => {\n                return path.join('.').startsWith(nodePath.join('.'))\n              })\n\n              const nearestParent = parents.reduce(function (a, b) {\n                return a.length < b.length ? a : b\n              })\n              Object.keys(value).map((key) => {\n                if (\n                  [\n                    '__typename',\n                    '_internalSys',\n                    '_internalValues',\n                    '_sys',\n                  ].includes(key)\n                ) {\n                  return false\n                }\n                fields[key] = [\n                  ...path.slice(nearestParent.length + 1),\n                  key,\n                ].join('.')\n              })\n              value[META_KEY] = {\n                id: value?._internalSys.path,\n                name: path.slice(nearestParent.length).join('.'),\n                fields,\n              }\n            } else if (\n              typeof value === 'object' &&\n              !Array.isArray(value) &&\n              value !== null\n            ) {\n              if (key !== META_KEY) {\n                const parents = nodePaths.filter((nodePath) => {\n                  return path.join('.').startsWith(nodePath.join('.'))\n                })\n                if (parents.length) {\n                  const nearestParent = parents.reduce(function (a, b) {\n                    return a.length < b.length ? a : b\n                  })\n                  const parent = getIn(newData.data, nearestParent.join('.'))\n                  const id = parent._internalSys.path\n                  const fields = {}\n                  Object.keys(value).map((key) => {\n                    if (\n                      [\n                        '__typename',\n                        '_internalSys',\n                        '_internalValues',\n                        '_sys',\n                      ].includes(key)\n                    ) {\n                      return false\n                    }\n\n                    fields[key] = [\n                      ...path.slice(nearestParent.length),\n                      key,\n                    ].join('.')\n                  })\n                  value[META_KEY] = {\n                    id,\n                    name: path.slice(nearestParent.length).join('.'),\n                    fields,\n                  }\n                }\n              }\n            }\n          }\n          return { data: newData.data }\n        },\n        initializer: async (context, event) => {\n          const tina = context.cms.api.tina as Client\n          const schema = await tina.getSchema()\n          const documentNode = G.parse(event.value.query)\n          const { formifiedQuery } = await formify({\n            schema,\n            optimizedDocumentNode: documentNode,\n          })\n          const data = (await context.cms.api.tina.request(\n            G.print(formifiedQuery),\n            {\n              variables: event.value.variables,\n            }\n          )) as DataType\n          const documents: Data[] = []\n          // step through every value in the payload to find the documents\n          JSON.stringify(data, (key, value) => {\n            if (value?._internalValues) {\n              documents.push(value)\n            }\n            return value\n          })\n          return {\n            data,\n            documents,\n            variables: event.value.variables,\n            documentNode: formifiedQuery,\n            id: event.value.id,\n          }\n        },\n        onChangeCallback: (context) => (callback, _onReceive) => {\n          const schema = context.cms.api.tina.schema as TinaSchema\n          Object.values(context.documentMap).forEach((documentMachine) => {\n            if (!context.registerSubForms) {\n              if (documentMachine.skipFormRegister) {\n                return\n              }\n            }\n            const documentContext = documentMachine.ref.getSnapshot()?.context\n            const collectionName =\n              documentContext?.data?._internalSys.collection.name\n\n            const collection = schema.getCollection(\n              collectionName || ''\n            ) as TinaCollection\n            if (documentContext?.form) {\n              if (collection.ui?.global) {\n                context.cms.plugins.add(\n                  new GlobalFormPlugin(documentContext.form)\n                )\n              } else {\n                context.cms.forms.add(documentContext.form)\n              }\n            }\n          })\n        },\n      },\n    }\n  )\nclass QueryError extends Error {\n  public id: string\n  public skipFormRegister: boolean\n  constructor(message: string, id: string, skipFormRegister: boolean) {\n    super(message) // (1)\n    this.name = 'QueryError' // (2)\n    this.id = id\n    this.skipFormRegister = skipFormRegister\n  }\n}\n\nconst isNodeType = (type: G.GraphQLOutputType) => {\n  const namedType = G.getNamedType(type)\n  if (G.isInterfaceType(namedType)) {\n    if (namedType.name === 'Node') {\n      return true\n    }\n  }\n  if (G.isUnionType(namedType)) {\n    const types = namedType.getTypes()\n    if (\n      types.every((type) => {\n        return type.getInterfaces().some((intfc) => intfc.name === 'Node')\n      })\n    ) {\n      return true\n    }\n  }\n  if (G.isObjectType(namedType)) {\n    if (namedType.getInterfaces().some((intfc) => intfc.name === 'Node')) {\n      return true\n    }\n  }\n}\n\nconst resolveFormValue = <T extends Record<string, unknown>>({\n  fields,\n  values,\n  tinaSchema,\n}: {\n  fields: TinaFieldEnriched[]\n  values: T\n  tinaSchema: TinaSchema\n}): T & { __typename?: string } => {\n  const accum: Record<string, unknown> = {}\n  fields.forEach((field) => {\n    const v = values[field.name]\n    if (typeof v === 'undefined') {\n      return\n    }\n    if (v === null) {\n      return\n    }\n    accum[field.name] = resolveFieldValue({\n      field,\n      value: v,\n      tinaSchema,\n    })\n  })\n  return accum as T & { __typename?: string }\n}\nconst resolveFieldValue = ({\n  field,\n  value,\n  tinaSchema,\n}: {\n  field: TinaFieldEnriched\n  value: unknown\n  tinaSchema: TinaSchema\n}) => {\n  switch (field.type) {\n    case 'object': {\n      if (field.templates) {\n        if (field.list) {\n          if (Array.isArray(value)) {\n            return value.map((item) => {\n              const template = field.templates[item._template]\n              if (typeof template === 'string') {\n                throw new Error('Global templates not supported')\n              }\n              return {\n                __typename: NAMER.dataTypeName(template.namespace),\n                ...resolveFormValue({\n                  fields: template.fields,\n                  values: item,\n                  tinaSchema,\n                }),\n              }\n            })\n          }\n        } else {\n          // not implemented\n        }\n      }\n\n      const templateFields = field.fields\n      if (typeof templateFields === 'string') {\n        throw new Error('Global templates not supported')\n      }\n      if (!templateFields) {\n        throw new Error(`Expected to find sub-fields on field ${field.name}`)\n      }\n      if (field.list) {\n        if (Array.isArray(value)) {\n          return value.map((item) => {\n            return {\n              __typename: NAMER.dataTypeName(field.namespace),\n              ...resolveFormValue({\n                fields: templateFields,\n                values: item,\n                tinaSchema,\n              }),\n            }\n          })\n        }\n      } else {\n        return {\n          __typename: NAMER.dataTypeName(field.namespace),\n          ...resolveFormValue({\n            fields: templateFields,\n            values: value as any,\n            tinaSchema,\n          }),\n        }\n      }\n    }\n    default: {\n      return value\n    }\n  }\n}\n","/**\n\n*/\nimport React from 'react'\nimport { useMachine } from '@xstate/react'\nimport { queryMachine, initialContext } from './lib/machines/query-machine'\nimport { useCMS, defineConfig } from 'tinacms'\nimport type { formifyCallback as FormifyCallback } from 'tinacms/dist/hooks/use-graphql-forms'\n\ntype Config = Parameters<typeof defineConfig>[0]\n\ntype PostMessage = {\n  type: 'open' | 'close' | 'isEditMode'\n  id: string\n  data: object\n}\n\nexport const Preview = (\n  props: Config & {\n    url: string\n    iframeRef: React.MutableRefObject<HTMLIFrameElement>\n  }\n) => {\n  const [activeQuery, setActiveQuery] = React.useState<PostMessage | null>(null)\n\n  React.useEffect(() => {\n    if (props.iframeRef.current) {\n      window.addEventListener('message', (event: MessageEvent<PostMessage>) => {\n        if (event.data.type === 'open') {\n          setActiveQuery(event.data)\n        }\n      })\n      window.addEventListener('message', (event: MessageEvent<PostMessage>) => {\n        if (event?.data?.type === 'isEditMode') {\n          props.iframeRef?.current?.contentWindow?.postMessage({\n            type: 'tina:editMode',\n          })\n        }\n      })\n    }\n  }, [props.iframeRef.current])\n\n  return (\n    <div className=\"tina-tailwind\">\n      {activeQuery && (\n        <QueryMachine\n          key={activeQuery.id}\n          payload={activeQuery}\n          iframeRef={props.iframeRef}\n          formifyCallback={props.formifyCallback}\n        />\n      )}\n      <iframe\n        id=\"tina-iframe\"\n        ref={props.iframeRef}\n        className=\"h-screen w-full bg-white\"\n        src={props.url}\n      />\n    </div>\n  )\n}\n\nconst QueryMachine = (props: {\n  payload: PostMessage\n  iframeRef: React.MutableRefObject<HTMLIFrameElement>\n  formifyCallback: FormifyCallback\n}) => {\n  const cms = useCMS()\n\n  const machine = React.useMemo(\n    () =>\n      queryMachine.withContext({\n        ...initialContext,\n        cms,\n        // Enable registration of sub forms\n        // registerSubForms: true,\n        // @ts-ignore FIXME: add formifyCallback args to Config type\n        formifyCallback: props.formifyCallback,\n      }),\n    []\n  )\n\n  const [state, send] = useMachine(machine)\n  React.useEffect(() => {\n    const unsubscribeFieldChange = cms.events.subscribe(\n      `forms:fields:onChange`,\n      (event) => {\n        // Nested forms from rich-text also trigger this event\n        if (Object.keys(state.context.documentMap).includes(event.formId)) {\n          send({ type: 'FIELD_CHANGE' })\n        }\n      }\n    )\n    const unsubscribeReset = cms.events.subscribe(`forms:reset`, (event) => {\n      if (Object.keys(state.context.documentMap).includes(event.formId)) {\n        send({ type: 'FIELD_CHANGE' })\n      }\n    })\n\n    return () => {\n      unsubscribeFieldChange()\n      unsubscribeReset()\n    }\n  }, [cms, state.context.documentMap])\n\n  React.useEffect(() => {\n    if (state.matches('pipeline.ready')) {\n      cms.events.dispatch({ type: 'forms:register', value: 'complete' })\n    } else if (state.matches('pipeline.initializing')) {\n      cms.events.dispatch({ type: 'forms:register', value: 'start' })\n    }\n  }, [JSON.stringify(state.value)])\n\n  React.useEffect(() => {\n    if (props.iframeRef.current) {\n      send({ type: 'IFRAME_MOUNTED', value: props.iframeRef.current })\n      if (props.payload.type === 'open') {\n        send({ type: 'ADD_QUERY', value: props.payload })\n      }\n      window.addEventListener('message', (event: MessageEvent<PostMessage>) => {\n        // useTinaHook cleans itself up when the component unmounts by sending a close message\n        if (event.data.type === 'close') {\n          send({ type: 'REMOVE_QUERY' })\n        }\n      })\n    }\n  }, [props.iframeRef.current])\n\n  return null\n}\n","import { defineConfig as e } from \"tinacms\";\nconst t = process.env.HEAD || process.env.VERCEL_GIT_COMMIT_REF || \"main\", o = e({\n  branch: t,\n  clientId: process.env.CLIENT_ID,\n  token: process.env.READ_TOKEN,\n  build: {\n    outputFolder: \"admin\",\n    publicFolder: \"./\"\n  },\n  media: {\n    tina: {\n      mediaRoot: \"\",\n      publicFolder: \"./\"\n    }\n  },\n  schema: {\n    collections: [\n      {\n        name: \"post\",\n        label: \"Posts\",\n        path: \"_posts\",\n        format: \"md\",\n        fields: [\n          {\n            type: \"string\",\n            name: \"title\",\n            label: \"Title\",\n            isTitle: !0,\n            required: !0\n          },\n          {\n            type: \"rich-text\",\n            name: \"body\",\n            label: \"Body\",\n            isBody: !0\n          }\n        ]\n      },\n      {\n        name: \"page\",\n        label: \"Pages\",\n        path: \"_pages\",\n        format: \"md\",\n        fields: [\n          {\n            type: \"string\",\n            name: \"title\",\n            label: \"Title\",\n            isTitle: !0,\n            required: !0\n          },\n          {\n            type: \"rich-text\",\n            name: \"body\",\n            label: \"Body\",\n            isBody: !0\n          }\n        ]\n      }\n    ]\n  }\n});\nexport {\n  o as default\n};\n","import React, { Suspense } from 'react'\nimport TinaCMS, { TinaAdmin, useCMS, MdxFieldPluginExtendible } from 'tinacms'\nimport { TinaEditProvider, useEditState } from 'tinacms/dist/edit-state'\nimport { Preview } from './preview'\n\n// TODO: Resolve this to local file in tsconfig.json\n// @ts-expect-error\nimport config from 'TINA_IMPORT'\n// @ts-expect-error\nimport schemaJson from 'SCHEMA_IMPORT'\n\nconst RawEditor = React.lazy(() => import('./fields/rich-text'))\n\nconst Editor = (props) => {\n  const [rawMode, setRawMode] = React.useState(false)\n  return (\n    <MdxFieldPluginExtendible.Component\n      rawMode={rawMode}\n      setRawMode={setRawMode}\n      {...props}\n      rawEditor={\n        <Suspense fallback={<div>Loading raw editor...</div>}>\n          <RawEditor {...props} setRawMode={setRawMode} rawMode={rawMode} />\n        </Suspense>\n      }\n    />\n  )\n}\n\nconst SetPreview = ({ outputFolder }: { outputFolder: string }) => {\n  const cms = useCMS()\n  cms.flags.set('tina-preview', outputFolder)\n  // Override original 'rich-text' field with one that has raw mode support\n  cms.fields.add({\n    ...MdxFieldPluginExtendible,\n    Component: Editor,\n  })\n  return null\n}\n\nexport const TinaAdminWrapper = () => {\n  const schema = { ...config?.schema, config }\n  return (\n    // @ts-ignore JSX element type 'TinaCMS' does not have any construct or call signatures.ts(2604)\n    <TinaCMS {...config} schema={schema} client={{ apiUrl: __API_URL__ }}>\n      <SetPreview outputFolder={config.build.outputFolder} />\n      <TinaAdmin preview={Preview} config={config} schemaJson={schemaJson} />\n    </TinaCMS>\n  )\n}\n\nconst GoToEdit = () => {\n  const { setEdit } = useEditState()\n  setEdit(true)\n  return <div>Going into edit mode</div>\n}\n\nfunction App() {\n  return (\n    <TinaEditProvider editMode={<TinaAdminWrapper />}>\n      <GoToEdit />\n    </TinaEditProvider>\n  )\n}\nexport default App\n","/**\n\n*/\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport './index.css'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"file":"assets/index.e6c24de7.js"}